/*
* --== Coding Style principles ==--
* Object starting with a maj are objects/protypes of nature (rule exception: if they start with relevant abreviations i.e. IKSomething)
* GLOBAL variables must be constants if applicable and are always declared in header right after the imports in ALLCAPS
* single characters and single words are quoted with '' and longer strings that can contain spaces with ""
* index.html automatically calls main() on load as it is the main app thread and it must pilot everthing else
* every function and variables must be ignorant, file specific variables must be retrieved from CONFIG
* any generic JS function must be implemented within FUNCTIONS
* any material setup must be done within MATERIALS
* any complex operation used more than once must be implemented in a dedicated function
*/

import { version } from '../package.json';
import './style.css';

import * as THREE from 'three/webgpu';
import {
    OrbitControls,
    GLTFLoader,
    CCDIKSolver,
    CCDIKHelper,
    TransformControls,
    KTX2Loader,
    DRACOLoader
} from 'three/examples/jsm/Addons.js';
import Stats from 'three/addons/libs/stats.module.js';
import GUI from 'lil-gui';

import * as MATERIALS from './materials';
import * as FUNCTIONS from './genericFcts';
import * as DRAGGABLE from './draggable.js';
import * as DQS from './dualQuaternionSkinning.tsl.js';

import { color, mix, mx_fractal_noise_float, pass, positionView } from 'three/tsl';
import { MeshoptDecoder } from 'three/examples/jsm/libs/meshopt_decoder.module.js';

//global variables
let CONFIG;
const PROGRESS_STATE = {};
//scene globals
const SCENE = new THREE.Scene();
let CAMERA, RENDERER, CONTROLS, POST_PROCESSING;
//ray cast
let INTERSECTED;
const RAYCASTER = new THREE.Raycaster();
const POINTER = new THREE.Vector2();
//useful data sets
const IK_Solvers = {};
const MESH_LIST = {};
const GIZMO_LIST = {};
const GIZMO_HELPERS = {};
const BONES_GEO_LIST = [];
const BONES_INIT_TRANSFORMS = {};
//filter for extra mesh generated by GLTF conversion for material slots
const REGEX = new RegExp('\_[0-9]+$');
//animation globals
let ACTIVE_ACTION, PREVIOUS_ACTION, ACTIONS, MIXER;
const CLOCK = new THREE.Timer();
const API = {}; //interface API for UI

window.main = main;
async function main() {
    await FUNCTIONS.loadJSON('/characterConfig.json').then((JSONdata) => {
        CONFIG = JSONdata;
        Object.freeze(CONFIG);
    });
    await init();
    await load();
    RENDERER.setAnimationLoop(animate);
}

async function init() {
    document.getElementById('version').innerText = 'v' + version;

    //meta progress UI
    const progressGroup = document.createElement('div');
    const progressTitle = document.createElement('span');
    const progressStep = document.createElement('span');
    const loaderAnim = document.createElement('div');
    loaderAnim.classList.add('loader');
    progressGroup.id = 'progressGroup';
    progressGroup.inert = true;

    const neoMainElements = document.createElement('div');
    neoMainElements.classList.add('neo-main-element');
    progressGroup.classList.add('neo-border');
    progressGroup.appendChild(neoMainElements);
    neoMainElements.appendChild(progressTitle);

    const progressMainNeo = document.createElement('div');
    progressMainNeo.classList.add('neo-bar-wrapper');
    const progressMainNeoBar = document.createElement('div');
    progressMainNeoBar.classList.add('neo-bar');
    progressMainNeo.appendChild(progressMainNeoBar);

    neoMainElements.appendChild(progressMainNeo);
    neoMainElements.appendChild(progressStep);

    const progressSecondaryNeo = document.createElement('div');
    progressSecondaryNeo.classList.add('neo-bar-wrapper');
    const progressSecondaryNeoBar = document.createElement('div');
    progressSecondaryNeoBar.classList.add('neo-bar');
    progressSecondaryNeo.appendChild(progressSecondaryNeoBar);
    neoMainElements.appendChild(progressSecondaryNeo);
    neoMainElements.appendChild(loaderAnim);
    
    progressTitle.textContent = "Loading";
    document.getElementsByTagName('body')[0].appendChild(progressGroup);

    Object.assign(PROGRESS_STATE, {
        global: 0,
        substep: 0,
        current: "<Current Step>",
        total: 5
    });

    //progress data listener
    FUNCTIONS.onPropertyChange(PROGRESS_STATE, (p, v) => {
        switch (p) {
            case 'global':
                progressMainNeoBar.style.width = "calc(20rem * " + (v / 100) + ")";
                if (v >= 100) {
                    window.setTimeout(() => {
                        progressGroup.style.display = 'none';
                    }, 1500)
                }
                break;
            case 'substep':
                progressSecondaryNeoBar.style.width = "calc(20rem * " + (v / 100) + ")";
                break;
            case 'current':
                progressStep.textContent = v;
                break;
        }
    });

    const video = document.getElementById('video');

    //scene setup
    PROGRESS_STATE.global = 0 / PROGRESS_STATE.total * 100;
    PROGRESS_STATE.substep = 0;
    PROGRESS_STATE.current = "Initialazing scene";
    CAMERA = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    RENDERER = new THREE.WebGPURenderer({
        canvas: document.querySelector('#bg'),
        antialias: true,
        alpha: true,
        powerPreference: 'high-performance'
    });

    RENDERER.setPixelRatio(window.devicePixelRatio);
    RENDERER.setSize(window.innerWidth, window.innerHeight);

    CAMERA.setViewOffset(window.innerWidth * 3, window.innerHeight * 2, window.innerWidth * 1, window.innerHeight * 0.05, window.innerWidth, window.innerHeight);
    CAMERA.position.set(0, 1, 5);
    CAMERA.zoom = 2;
    CAMERA.updateProjectionMatrix();

    window.addEventListener('resize', () => {
        CAMERA.aspect = window.innerWidth / window.innerHeight;
        CAMERA.setViewOffset(window.innerWidth * 3, window.innerHeight * 2, window.innerWidth * 1, window.innerHeight * 0.05, window.innerWidth, window.innerHeight);
        CAMERA.updateProjectionMatrix();
        RENDERER.setSize(window.innerWidth, window.innerHeight);
    });

    //post processing
    POST_PROCESSING = new THREE.PostProcessing(RENDERER);
    const scenePass = pass( SCENE, CAMERA );
    const scenePassTM = scenePass.toneMapping(THREE.ACESFilmicToneMapping);
    POST_PROCESSING.outputNode = scenePassTM;

    //UI
    const gridHelper = new THREE.GridHelper(200, 50, 0x2c3e50);
    SCENE.add(gridHelper);
    CONTROLS = new OrbitControls(CAMERA, RENDERER.domElement);

    //lights
    const ambiantLight = new THREE.AmbientLight(0xffffff, 1);
    const pointLight1 = new THREE.PointLight(0xffffff, 1);
    const pointLight2 = new THREE.PointLight(0xffffff, 1);
    pointLight1.position.set(1, 1, 1);
    pointLight2.position.set(-1, 1, -1);
    SCENE.add(pointLight1, pointLight2, ambiantLight);

    PROGRESS_STATE.substep = 100;

    //API interface
    Object.assign(API, {
        pose: CONFIG.defaultPose,
        backgroundColor: 0x76ddfc,
        lightIntensity: 1.5,
        grid: false,
        selectedBone: null,
        skeletonHelperDisplay: false,
        skeletonHelper: null,
        selectedBoneGizmo: null,
        mode: 'rotate',
        resetBoneFct: () => {
            if (API.selectedBone) {
                switch (API.mode) {
                    case 'rotate':
                        API.selectedBone.setRotationFromEuler(BONES_INIT_TRANSFORMS[API.selectedBone.name].rotation);
                        break;
                    case 'translate':
                        API.selectedBone.position.set(
                            BONES_INIT_TRANSFORMS[API.selectedBone.name].position.x,
                            BONES_INIT_TRANSFORMS[API.selectedBone.name].position.y,
                            BONES_INIT_TRANSFORMS[API.selectedBone.name].position.z
                        );
                        break;
                    case 'scale':
                        API.selectedBone.scale.set(
                            BONES_INIT_TRANSFORMS[API.selectedBone.name].scale.x,
                            BONES_INIT_TRANSFORMS[API.selectedBone.name].scale.y,
                            BONES_INIT_TRANSFORMS[API.selectedBone.name].scale.z
                        );
                        break;
                }
            }
        },
        mirrorPose: false,
        IK: false,
        wireframe: false,
        backgroundImage: false,
        stats: new Stats(),
        renderStats: document.createElement('div'),
        statsVisible: false,
        gui: null,
        sklUImenu: null,
        breathing: true,
        breatheCtrl: null,
        blinkCtrls: []
    });
    //API listeners
    FUNCTIONS.onPropertyChange(API, (p, v) => {
        switch (p) {
            case 'mode':
                API.selectedBoneGizmo.setMode(v);
                break;
            case 'skeletonHelperDisplay':
                if (v) {
                    for (let i = 0; i < BONES_GEO_LIST.length; i++) {
                        SCENE.add(BONES_GEO_LIST[i]);
                    }
                } else {
                    API.selectedBoneGizmo.detach();
                    API.selectedBone = null;
                    API.sklUImenu.name('Show Bones');
                    API.gui.domElement.childNodes[1].innerText = 'Controls';
                    for (let i = 0; i < BONES_GEO_LIST.length; i++) {
                        SCENE.remove(BONES_GEO_LIST[i]);
                    }
                }
                break;
            case 'backgroundColor':
                if (!API.backgroundImage) SCENE.backgroundNode = mix(color(v), color(v).mul(2), mx_fractal_noise_float(positionView.mul(5)).mul(0.5));
                break;
            case 'grid':
                gridHelper.visible = v;
                break;
            case 'lightIntensity':
                ambiantLight.intensity = v;
                break;
            case 'backgroundImage':
                if(v) {
                    SCENE.backgroundNode = null;
                    if ( navigator.mediaDevices && navigator.mediaDevices.getUserMedia ) {
                        const constraints = { video: { facingMode: 'environment' } };
                        navigator.mediaDevices.getUserMedia( constraints ).then( function ( stream ) {
                            video.srcObject = stream;
                            video.play();
                            video.style.display = 'block';
                        } ).catch( function ( error ) {
                            console.error( "Unable to access the CAMERA/webcam.", error );
                        } );
                    } else {
                        console.error( "MediaDevices interface not available." );
                    }
                } else {
                    video.pause();
                    video.style.display = 'none';
                    SCENE.backgroundNode = mix(color(API.backgroundColor), color(API.backgroundColor).mul(2), mx_fractal_noise_float(positionView.mul(5)).mul(0.5));
                }
                break;
            case 'statsVisible':
                if(v) {
                    API.stats.dom.childNodes.forEach((c) => {c.style.display = 'block'});
                } else {
                    API.stats.dom.childNodes.forEach((c) => {c.style.display = 'none'});
                }
                break;
            case 'breathing':
                if (!v) {
                    if (API.breatheCtrl) {
                        API.breatheCtrl.enable();
                        API.breatheCtrl.setValue(0);
                    }
                    if (API.blinkCtrls.length > 0) {Object.values(API.blinkCtrls).forEach( e => {
                        e.enable();
                        e.setValue(0);
                    });}
                } else {
                    if (API.breatheCtrl) API.breatheCtrl.disable();
                    if (API.blinkCtrls.length > 0) Object.values(API.blinkCtrls).forEach( e => e.disable());
                }
                break;
        };
    });

    API.renderStats.style = `
        width: 70px;
        margin: 5px;
        font-size: 0.65em;
    `;
    API.stats.dom.appendChild(API.renderStats);

    //tracks pointer coords to update 'INTERSECTED' with any bone UI intersecting with pointer coords
    document.addEventListener('mousemove', (e) => FUNCTIONS.trackPointer(e, POINTER));

    await RENDERER.init();
};

async function load() {  
    const srcFile = CONFIG.filePath;
    const loader = new GLTFLoader();

    /* decoders for compressed assets, used automatically if matching compression is detected in the file
    * compression methods don't seem to be beneficial on low end devices, additional runtime cost is too high compared to the vram gains
    * on high end devices loading is improved and performance cost on runtime is worth it
    */
    const ktx2Loader = new KTX2Loader();
    ktx2Loader.setTranscoderPath('/loaders/basis/');
    ktx2Loader.detectSupport(RENDERER);
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderConfig({type: 'js'});
    dracoLoader.setDecoderPath('/loaders/draco/');
    loader.setDRACOLoader(dracoLoader);
    loader.setKTX2Loader(ktx2Loader);
    loader.setMeshoptDecoder(MeshoptDecoder);
    
    //init meta progress values
    PROGRESS_STATE.global = 1 / PROGRESS_STATE.total * 100;
    PROGRESS_STATE.substep = 0;
    PROGRESS_STATE.current = "Unpacking scene";

    await loader.loadAsync(
        srcFile,
        (data) => {
            PROGRESS_STATE.substep = data.loaded / data.total * 100;
        }
    ).then(
        (data) => {
            //init meta progress values
            PROGRESS_STATE.global = 2 / PROGRESS_STATE.total * 100;
            PROGRESS_STATE.substep = 0;
            PROGRESS_STATE.current = "Initializing scene";
            let count = 0;
            data.scene.traverse(() => { count++; });
            let progress = 0;

            RENDERER.compile(data.scene, CAMERA, SCENE);

            let skinnedMeshReference;

            data.scene.traverse((object) => {
                if (object instanceof THREE.Mesh) {
                    //populate meshList for visibility toggles
                    if (!REGEX.test(object.name)) {
                        MESH_LIST[object.name] = true;
                    } else {
                        let subName = object.name.replace(REGEX, '');
                        MESH_LIST[subName] = true;
                    }
                    //apply materials
                    Object.keys(CONFIG.matApplication).forEach(m => {
                        if (CONFIG.matApplication[m].includes(object.name)) {
                            if (m == 'diffuseMaterial') {
                                object.material.vertexColors = false;
                                object.material = MATERIALS.convertMaterialToNodes(object.material);
                            } else {
                                object.material = MATERIALS[m];
                            }
                        }
                    });
                    if (!skinnedMeshReference && object.skeleton) skinnedMeshReference = object;
                    if (CONFIG.skinnedMeshNames.includes(object.name)) {
                        object.material = MATERIALS.convertMaterialToNodes(object.material);
                        DQS.enableDQS(object, false);
                    }
                } else {
                    if (object instanceof THREE.Bone) {
                        BONES_INIT_TRANSFORMS[object.name] = {
                            position: Object.assign({}, object.position),
                            rotation: Object.assign({}, object.rotation),
                            scale: Object.assign({}, object.scale)
                        };
                    }
                }
                progress++;
                PROGRESS_STATE.substep = progress / count * 100;
            });

            API.skeletonHelper = new THREE.SkeletonHelper(data.scene);
            generateUIskeleton(API.skeletonHelper, CONFIG.boneCtrlExclusions);
            setupCustomCtrls(API.skeletonHelper, skinnedMeshReference);
            createGUI(data.scene, data.animations, CONFIG.hiddenMeshes);

            SCENE.add(data.scene);

            PROGRESS_STATE.global = 5 / PROGRESS_STATE.total * 100;
            PROGRESS_STATE.substep = 100;
            PROGRESS_STATE.current = "Finishing work";
        },
        (error) => {
            console.error(error);
        }
    );
}

let f = 0;
function animate() {

    if (f < 10) f++; //need to wait a few frames to assert renderer and if fallback is in place or not
    else document.getElementById('renderer').innerText = RENDERER.backend.isWebGPUBackend ? 'WebGPU' : 'WebGL';

    //update IK
    if (API.IK && IK_Solvers && API.pose == 'Default') {
        Object.values(IK_Solvers).forEach(e => {
            e.update();
        })
    }

    //update meshes visibility
    SCENE.traverse(function (obj) {
        if (obj.isSkinnedMesh) obj.computeBoundingSphere();
        if (obj instanceof THREE.Mesh) {
            let subName = obj.name.replace(REGEX, '');
            obj.visible = MESH_LIST[subName];
            if(MESH_LIST[subName]) obj.material.wireframe = API.wireframe;
        }
    });

    //update skeleton helper UI position
    for (let i = 0; i < BONES_GEO_LIST.length; i++) {
        if (API.skeletonHelperDisplay) {
            let target = new THREE.Vector3();
            API.skeletonHelper.bones.find(b => b.name == BONES_GEO_LIST[i].name).getWorldPosition(target);
            BONES_GEO_LIST[i].position.set(target.x, target.y, target.z);

            let scale = new THREE.Vector3().subVectors(BONES_GEO_LIST[i].position, CAMERA.position).length() * 0.2;
            BONES_GEO_LIST[i].scale.set(scale, scale, scale)
        }
    }

    //update mirrored bones transformations
    if (API.mirrorPose) {
        if (API.selectedBone && getMirrorBoneName(API.selectedBone.name) != 'none') {
            let mirrorBone = API.skeletonHelper.bones.find(b => b.name == getMirrorBoneName(API.selectedBone.name));
            switch (API.mode) {
                case 'rotate':
                    let rotation = new THREE.Euler(API.selectedBone.rotation.x, -API.selectedBone.rotation.y, -API
                        .selectedBone.rotation.z, API.selectedBone.rotation.order);
                    mirrorBone.setRotationFromEuler(rotation);
                    break;
                case 'translate':
                    mirrorBone.position.set(-API.selectedBone.position.x, API.selectedBone.position.y, API.selectedBone
                        .position.z);
                    break;
                case 'scale':
                    mirrorBone.scale.set(API.selectedBone.scale.x, API.selectedBone.scale.y, API.selectedBone.scale.z);
                    break;
            }
        };
    }

    //update gizmos visibility
    Object.keys(GIZMO_HELPERS).forEach(e => {
        GIZMO_LIST[e] = API.IK; //IK button toggles them all
        if (GIZMO_LIST[e] == false) {
            SCENE.remove(GIZMO_HELPERS[e]);
        } else {
            SCENE.add(GIZMO_HELPERS[e]);
        }
    })

    if (MIXER) MIXER.update(CLOCK.getDelta());

    //manual morph target animation adjustments if specified
    if (CONFIG.poseExtraSettings[API.pose]) {
        if (CONFIG.poseExtraSettings[API.pose].morphs) {
            API.gui.children.forEach(e => {
                if (e._title == "Morph targets") { e.children.forEach(g => {
                    if (g._title == 'Body') { g.children.forEach(c => {
                        Object.keys(CONFIG.poseExtraSettings[API.pose].morphs).forEach(t => {
                            if (c._name == t) c.setValue(CONFIG.poseExtraSettings[API.pose].morphs[t]);
                        });
                    })}
                })}
            });
        }
    }

    //'Alive' loop -- based on timeStamp rather than clock.delta because it's independant of animation time scaling and progress
    if (API.breathing) {
        if (API.breatheCtrl) {
            let overriden = false;
            if (CONFIG.poseExtraSettings[API.pose]) if (CONFIG.poseExtraSettings[API.pose].dynamicMorphsOverride) if(CONFIG.poseExtraSettings[API.pose].dynamicMorphsOverride.includes("breatheKey")) overriden = true;
            if (!overriden) API.breatheCtrl.setValue(Math.sin((performance.now()*0.0025))*0.35+0.35);
        }
        if (API.blinkCtrls.length > 0) {
            let overriden = false;
            if (CONFIG.poseExtraSettings[API.pose]) if (CONFIG.poseExtraSettings[API.pose].dynamicMorphsOverride) if(CONFIG.poseExtraSettings[API.pose].dynamicMorphsOverride.includes("blinkKeys")) overriden = true;
            if (!overriden) {
                let blinkValue = Math.sin((performance.now()*0.0015))*25-24;            
                if (blinkValue >= 0) Object.values(API.blinkCtrls).forEach(e => {if(blinkValue > 0) e.setValue(blinkValue)});
                else Object.values(API.blinkCtrls).forEach(e => e.setValue(0));
            }
        }
    }

    DQS.updateDQS();

    //ray cast
    if (RAYCASTER && API.skeletonHelperDisplay) {
        RAYCASTER.setFromCamera(POINTER, CAMERA);
        const intersects = RAYCASTER.intersectObjects(BONES_GEO_LIST, false);
        if (intersects.length > 0) {
            INTERSECTED = intersects[0].object;
            INTERSECTED.material.color = new THREE.Color(0xffff00);
        } else {
            for (let i = 0; i < BONES_GEO_LIST.length; i++) {
                BONES_GEO_LIST[i].material.color = new THREE.Color(0xffffff);
            }
            INTERSECTED = null;
        }
    }

    //draw new frame
    POST_PROCESSING.renderAsync();

    CLOCK.update();
    API.stats.update();
    API.renderStats.textContent = `
        ${RENDERER.info.render.drawCalls} draw calls
        ${RENDERER.info.render.triangles} triangles
    `;
}

function createGUI(scene, animations, hiddenMeshes) {
    //init meta progress values
    PROGRESS_STATE.global = 4 / PROGRESS_STATE.total * 100;
    PROGRESS_STATE.substep = 0;
    PROGRESS_STATE.current = "Making UI";
    let progress = 0;
    let count = 4;
    PROGRESS_STATE.substep = ++progress / count * 100;

    //init GUI
    API.gui = new GUI();
    
    const poses = [];
    ACTIONS = {};
    MIXER = new THREE.AnimationMixer(scene);

    //Interface general controls
    const sceneFolder = API.gui.addFolder("Interface");
    sceneFolder.addColor(API, 'backgroundColor').name("Background Color");
    sceneFolder.add(API, 'backgroundImage').name("Camera Background");
    sceneFolder.add(API, 'lightIntensity', 1, 5, 0.1).name("Light Intensity");
    sceneFolder.add(API, 'grid').name("3D Grid");
    sceneFolder.add(API, 'wireframe').name("Wireframe");
    sceneFolder.add(API, 'statsVisible').name("Show App Stats");
    
    //setup skeleton UI gizmo
    let gizmoSlct = new TransformControls(CAMERA, RENDERER.domElement);
    gizmoSlct.setMode('translate');
    gizmoSlct = reskinGizmo(gizmoSlct);
    gizmoSlct.setMode('scale');
    gizmoSlct = reskinGizmo(gizmoSlct);
    gizmoSlct.setMode('rotate');
    gizmoSlct = reskinGizmo(gizmoSlct);

    gizmoSlct.space = 'local';
    gizmoSlct.size = 0.3;
    gizmoSlct.addEventListener('mouseDown', () => CONTROLS.enabled = false);
    gizmoSlct.addEventListener('mouseUp', () => CONTROLS.enabled = true);
    
    API.selectedBoneGizmo = gizmoSlct;
    
    RENDERER.domElement.addEventListener('click', () => {
        if (INTERSECTED) {
            let bone = API.skeletonHelper.bones.find(b => b.name == INTERSECTED.name);
            API.selectedBoneGizmo.attach(bone);
            API.selectedBone = bone;
            scene.add(API.selectedBoneGizmo.getHelper());
            API.sklUImenu.name("Show Bones (" + INTERSECTED.name + ")");
            if (API.gui._closed) API.gui.domElement.childNodes[1].innerText = "Controls (" + INTERSECTED.name + ")";
            else API.gui.domElement.childNodes[1].innerText = 'Controls';
        }
    });

    const scenePoseFolder = API.gui.addFolder("Pose utils");
    API.sklUImenu = scenePoseFolder.add(API, 'skeletonHelperDisplay').name("Show Bones");
    scenePoseFolder.add(API, 'mode').options(['rotate', 'translate', 'scale']).name("Mode");
    scenePoseFolder.add(API, 'resetBoneFct').name("Reset Bone");
    scenePoseFolder.add(API, 'mirrorPose').name("Mirror Pose");
    let IKCtrl;
    if (Object.keys(IK_Solvers).length > 0) IKCtrl = scenePoseFolder.add(API, 'IK').name("IK Controls");
    if (IKCtrl) IKCtrl.onChange((bool) => { if (bool) clipCtrl.setValue('Default'); })

    PROGRESS_STATE.substep = ++progress / count * 100;

    //mesh list
    const meshFolder = API.gui.addFolder("Meshes");
    Object.keys(MESH_LIST).forEach(e => {
        let toggle = meshFolder.add(MESH_LIST, e).name(e);
        hiddenMeshes.forEach(m => {
            if (m == e) {
                toggle.setValue(false);
            }
        })
    });

    //shape keys
    const expressionFolder = API.gui.addFolder("Morph targets");
    let found = false;
    scene.traverse(m => {
        if (m instanceof THREE.Mesh) {
            if (CONFIG.morphMeshList.includes(m.name)) {
                let morphMeshFolder = expressionFolder.addFolder(m.name.split('_')[0]);
                registerMorphMesh(scene, m, morphMeshFolder);
                found = true;
            }
        }
    });
    if (!found) console.warn("No matching mesh for morphTargets found. Looking for:", CONFIG.morphMeshList);

    //add search bar to morph target lists
    for (let i = 0; i < expressionFolder.domElement.childNodes[1].childNodes.length; i++) {
        let searchBar = addSearch(expressionFolder.domElement.childNodes[1].childNodes[i].childNodes[1]);
        if (searchBar) {
            let div = document.createElement('div');
            div.classList.add('controller');
            div.appendChild(searchBar);
            expressionFolder.domElement.childNodes[1].childNodes[i].childNodes[1].prepend(div);
        }
    }

    PROGRESS_STATE.substep = ++progress / count * 100;

    //retreive poses (or animations)
    for (let i = 0; i < animations.length; i++) {
        const clip = animations[i];
        poses.push(animations[i].name);
        const action = MIXER.clipAction(clip);
        ACTIONS[clip.name] = action;
        if (poses.indexOf(clip.name) >= 0) {
            action.clampWhenFinished = true;
        }
    }

    //poses (or animations)
    const poseFolder = API.gui.addFolder("Poses & animations");
    const clipCtrl = poseFolder.add(API, 'pose').options(poses).name("Active");
    clipCtrl.onChange(() => {
        if (IKCtrl && API.pose != 'Default') IKCtrl.setValue(false);
        fadeToAction(API.pose, 0.5);
        //automatic mesh toggling animations if specified
        if (CONFIG.poseExtraSettings[API.pose]) {
            if (CONFIG.poseExtraSettings[API.pose].meshes) {
                API.gui.children.forEach(e => {if (e._title == "Meshes") {e.children.forEach(m => {
                    if (CONFIG.poseExtraSettings[API.pose].meshes[m._name] != undefined) m.setValue(CONFIG.poseExtraSettings[API.pose].meshes[m._name]);
                })}});
            }
        }
    });
    poseFolder.add(API, 'breathing').name('Alive');
    poseFolder.open();

    CONFIG.poseExtraSettings.morphClearDefault.forEach((e) => {
        expressionFolder.children.forEach((c) => {
            c.children.forEach((t) => {
                if (t._name == e) t.setValue(0);
            });
        });
    });
    ACTIVE_ACTION = ACTIONS[CONFIG.defaultPose];
    if (ACTIVE_ACTION) ACTIVE_ACTION.play();
    else console.warn("Default pose '"+ CONFIG.defaultPose + "' was not found.");
    PROGRESS_STATE.substep = ++progress / count * 100;

    scenePoseFolder.close();
    meshFolder.close();
    expressionFolder.close();
    API.gui.close();

    DRAGGABLE.makeElementTouchDraggable(API.gui.domElement);

    //external stats UI
    document.body.appendChild(API.stats.dom);
    API.stats.dom.inert = true;
    API.stats.dom.style.margin = "10% 0.5em";

    //trigger listeners to initialize & sync API values
    Object.keys(API).forEach((param) => {
        API[param] = API[param];
    });

    //Liquid FX filter
    /*const liquidFX = document.createElement('div');
    liquidFX.classList.add('liquidFX');
    API.gui.domElement.appendChild(liquidFX);*/
}

function registerMorphMesh(scene, morphMesh, folder) {
    const expressions = morphMesh.morphTargetDictionary ? Object.keys(morphMesh.morphTargetDictionary) : [];
    for (let i = 0; i < expressions.length; i++) {
        let ctrl = folder.add(morphMesh.morphTargetInfluences, i, 0, 1, 0.01).name(expressions[i]);
        
        //retreives breathing and blinking morphTarget
        if (expressions[i] == CONFIG.breatheKey) API.breatheCtrl = ctrl;
        if (CONFIG.blinkKeys.includes(expressions[i])) API.blinkCtrls.push(ctrl);

        let subMeshCollection = {};
        scene.traverse(function (obj) {
            if (obj instanceof THREE.Mesh) {
                if (obj.morphTargetDictionary != undefined) {
                    let x = obj.morphTargetDictionary[expressions[i]];
                    if (x != undefined) {
                        subMeshCollection[obj.name] = obj;
                    }
                }
            }
        })
        ctrl.onChange((v) => {
            Object.values(subMeshCollection).forEach((e) => {
                e.morphTargetInfluences[e.morphTargetDictionary[expressions[i]]] = v;
            })
        });
    };
    if (!API.breatheCtrl) console.warn("Breathing animation: MorphTarget for blinking not found.");
    if (API.blinkCtrls.length == 0) console.warn("Breathing animation: MorphTargets for breathing not found.");
}

function addSearch(DOMelementLists) {
    if (DOMelementLists.childNodes.length > 10) {
        let searchBar = document.createElement('input');
        searchBar.type = 'text';
        searchBar.classList.add('search');
        searchBar.placeholder = "Filter by name ...";
        
        searchBar.addEventListener('keyup', () => {
            //skips 1st element as it should be the search input, not a list element
            for (let i = 1; i < DOMelementLists.childNodes.length; i++) {
                if (DOMelementLists.childNodes[i].textContent.toUpperCase().indexOf(searchBar.value.toUpperCase()) > -1) {
                    DOMelementLists.childNodes[i].style.display = '';
                } else {
                    DOMelementLists.childNodes[i].style.display = 'none';
                }
            }
        });
        return searchBar;
    }
    return;
}

function fadeToAction(name, duration) {
    PREVIOUS_ACTION = ACTIVE_ACTION;
    ACTIVE_ACTION = ACTIONS[name];
    if (PREVIOUS_ACTION !== ACTIVE_ACTION) {
        if(PREVIOUS_ACTION) PREVIOUS_ACTION.fadeOut(duration);
    }
    if (ACTIVE_ACTION._clip.duration > 0) { //actions are stored directly instead of raw animations, duration is part of the clip child which is the raw animation
        ACTIVE_ACTION.loop = THREE.LoopRepeat;
    } else {
        ACTIVE_ACTION.loop = THREE.LoopOnce;
    }
    ACTIVE_ACTION
        .reset()
        .setEffectiveTimeScale(1)
        .setEffectiveWeight(1)
        .fadeIn(duration)
        .play();
}

function reskinGizmo(gizmo) {
    const colors = {
        x: new THREE.Color(0xe74c3c),
        y: new THREE.Color(0xecc71),
        z: new THREE.Color(0x2980b9),
        xyz: new THREE.Color(0xf1c40f)
    }
    switch (gizmo.mode) {
        case 'translate':
            gizmo._gizmo.gizmo.translate.traverse(child => {
                if (child instanceof THREE.Mesh && (child.name == 'X' || child.name == 'Y' || child.name == 'Z')) {
                    child.geometry = new THREE.CylinderGeometry(0.04, 0.04, 1, 12);
                    let newMat = new THREE.MeshMatcapMaterial({});
                    newMat.copy(MATERIALS.gizmoMaterial);
                    switch (child.name) {
                        case 'X':
                            child.geometry.rotateX(0.5 * Math.PI).rotateY(0.5 * Math.PI);
                            newMat.color = colors.x;
                            break;
                        case 'Y':
                            newMat.color = colors.y;
                            break;
                        case 'Z':
                            child.geometry.rotateX(0.5 * Math.PI).rotateZ(0.5 * Math.PI);
                            newMat.color = colors.z;
                            break;
                    }
                    child.material = newMat;
                } else if (child instanceof THREE.Mesh && child.name == 'XYZ') {
                    child.geometry = new THREE.OctahedronGeometry(0.25, 0);
                    let newMat = new THREE.MeshMatcapMaterial({});
                    newMat.copy(MATERIALS.gizmoMaterial)
                    newMat.color = colors.xyz;
                    child.material = newMat;
                }
            });
            break;
        case 'rotate':
            gizmo._gizmo.gizmo.rotate.traverse(child => {
                if (child instanceof THREE.Mesh && (child.name == 'X' || child.name == 'Y' || child.name ==
                        'Z')) {
                    child.geometry = new THREE.TorusGeometry(0.5, 0.05, 12, 32);
                    let newMat = new THREE.MeshMatcapMaterial({});
                    newMat.copy(MATERIALS.gizmoMaterial);
                    switch (child.name) {
                        case 'X':
                            child.geometry.rotateY(0.5 * Math.PI);
                            newMat.color = colors.x;
                            break;
                        case 'Y':
                            child.geometry.rotateX(0.5 * Math.PI);
                            newMat.color = colors.y;
                            break;
                        case 'Z':
                            newMat.color = colors.z;
                            break;
                    }
                    child.material = newMat;
                } else if (child instanceof THREE.Mesh && child.name == 'E') {
                    child.geometry = new THREE.TorusGeometry(0.7, 0.035, 12, 32);
                    let newMat = new THREE.MeshMatcapMaterial({});
                    newMat.copy(MATERIALS.gizmoMaterial)
                    newMat.color = colors.xyz;
                    child.material = newMat;
                }
            })
            break;
        case 'scale':
            gizmo._gizmo.gizmo.scale.traverse(child => {
                if (child instanceof THREE.Mesh) {
                    let newMat = new THREE.MeshMatcapMaterial({});
                    newMat.copy(MATERIALS.gizmoMaterial);
                    let size = 0.15;
                    switch (child.name) {
                        case 'X':
                            child.geometry = new THREE.BoxGeometry(size, size, size);
                            child.geometry.translate(0.5, 0, 0);
                            newMat.color = colors.x;
                            break;
                        case 'Y':
                            child.geometry = new THREE.BoxGeometry(size, size, size);
                            child.geometry.translate(0, 0.5, 0);
                            newMat.color = colors.y;
                            break;
                        case 'Z':
                            child.geometry = new THREE.BoxGeometry(size, size, size);
                            child.geometry.translate(0, 0, 0.5);
                            newMat.color = colors.z;
                            break;
                        case 'XY':
                            newMat.color = colors.z;
                            break;
                        case 'XZ':
                            newMat.color = colors.y;
                            break;
                        case 'YZ':
                            newMat.color = colors.x;
                            break;
                        case 'XYZ':
                            newMat.color = colors.xyz;
                            break;
                    }
                    child.material = newMat;
                }
            });
            break;
    }
    return gizmo;
}

function gizmoSetup(name, space, mode, size, target) {
    let gizmo = new TransformControls(CAMERA, RENDERER.domElement);
    gizmo.space = space;
    gizmo.size = size;
    gizmo.setMode(mode);
    reskinGizmo(gizmo);
    GIZMO_LIST[name] = false;
    let gizmoHelper = gizmo.getHelper();
    GIZMO_HELPERS[name] = gizmoHelper;
    gizmo.addEventListener('mouseDown', () => CONTROLS.enabled = false);
    gizmo.addEventListener('mouseUp', () => CONTROLS.enabled = true);

    gizmo.attach(target);

    return gizmo;
}

function generateUIskeleton(skl, boneCtrlExclusions) {
    for (let i = 0; i < skl.bones.length; i++) {
        if (!boneCtrlExclusions.some(s => skl.bones[i].name.includes(s))) {
            let boneGeometry = new THREE.OctahedronGeometry(0.025, 3)
            let newMat = new THREE.MeshMatcapMaterial({});
            newMat.copy(MATERIALS.gizmoMaterial);
            let boneMesh = new THREE.Mesh(boneGeometry, newMat);
            let target = new THREE.Vector3();
            skl.bones[i].getWorldPosition(target);
            boneMesh.position.set(target.x, target.y, target.z);
            boneMesh.name = skl.bones[i].name;
            BONES_GEO_LIST.push(boneMesh);
            SCENE.add(boneMesh);
        }
    }
}

function getMirrorBoneName(name) {
    let mirrorName = name;
    let side = name.substr(name.length - 1)
    switch (side) {
        case 'L':
            mirrorName = mirrorName.replace(/.$/, 'R');
            break;
        case 'R':
            mirrorName = mirrorName.replace(/.$/, 'L');
            break;
        default:
            return 'none';
    }
    return mirrorName;
}

//IK setup
function setupCustomCtrls(sklHelper, sknMesh) {
    PROGRESS_STATE.global = 3 / PROGRESS_STATE.total * 100;
    PROGRESS_STATE.substep = 0;
    PROGRESS_STATE.current = "Setting up IK controls";
    let progress = 0;
    let count = Object.entries(CONFIG.IK).length;

    Object.entries(CONFIG.IK).forEach(e => {
        applyIK(sknMesh, e[0], setupIKchains(sklHelper, e[1]));
        PROGRESS_STATE.substep = ++progress / count * 100;
    });
}

function setupIKchains(sklHelper, IKChain) {
    if(IKChain.target && sklHelper.bones.findIndex(o => o.name == IKChain.target) != -1) {
        let computedLinks = [];
        for (let i = 1; i < IKChain.chain.length; i++) {
            computedLinks.push({index: sklHelper.bones.findIndex(o => o.name == IKChain.chain[i])})
        }
        const IKSettings = [{
            target: sklHelper.bones.findIndex(o => o.name == IKChain.target),
            effector: sklHelper.bones.findIndex(o => o.name == IKChain.chain[0]),
            links: computedLinks
        }];
        gizmoSetup(IKChain.target + 'Ctrl', 'world', 'translate', 0.2, sklHelper.bones.find(b => b.name == IKChain.target));
        return IKSettings;
    } else {
        console.warn(IKChain.target + ": Invalid IK setup provided, either bones are absent or settings are incorrect.")
    }
}

function applyIK(mesh, name, solver) {
    if (!solver) return null;
    IK_Solvers[name] = new CCDIKSolver(mesh, solver);
    let IKHelper = new CCDIKHelper(mesh, solver, 0.01);
    GIZMO_LIST[name + 'Helper'] = false;
    GIZMO_HELPERS[name + 'Helper'] = IKHelper;
    SCENE.add(IKHelper);

    return IKHelper;
}